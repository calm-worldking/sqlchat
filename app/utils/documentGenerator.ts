import fs from 'fs';
import path from 'path';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import puppeteer from 'puppeteer';

export interface DocumentOptions {
  title: string;
  content: string;
  author?: string;
  subject?: string;
}

// Генерация TXT файла
export async function generateTxtFile(content: string, filePath: string): Promise<void> {
  fs.writeFileSync(filePath, content, 'utf8');
}

// Генерация DOC файла
export async function generateDocFile(options: DocumentOptions, filePath: string): Promise<void> {
  const { title, content, author = 'SQL Chat', subject = 'Generated Report' } = options;

  // Разбиваем контент на параграфы
  const paragraphs = content.split('\n\n').filter(p => p.trim());

  const doc = new Document({
    creator: author,
    title: title,
    subject: subject,
    description: 'Generated by SQL Chat',
    sections: [{
      properties: {},
      children: [
        // Заголовок
        new Paragraph({
          text: title,
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          spacing: {
            after: 200,
            before: 200
          }
        }),
        // Содержимое
        ...paragraphs.map(paragraph => {
          // Проверяем, является ли параграф заголовком
          if (paragraph.startsWith('#')) {
            const level = paragraph.match(/^#+/)?.[0].length || 1;
            const text = paragraph.replace(/^#+\s*/, '');
            return new Paragraph({
              text: text,
              heading: level === 1 ? HeadingLevel.HEADING_1 : 
                       level === 2 ? HeadingLevel.HEADING_2 : 
                       level === 3 ? HeadingLevel.HEADING_3 : 
                       HeadingLevel.HEADING_4,
              spacing: {
                after: 100,
                before: 100
              }
            });
          }
          
          // Обычный параграф
          return new Paragraph({
            children: [
              new TextRun({
                text: paragraph,
                size: 24
              })
            ],
            spacing: {
              after: 100
            }
          });
        })
      ]
    }]
  });

  const buffer = await Packer.toBuffer(doc);
  fs.writeFileSync(filePath, buffer);
}

// Генерация PDF файла
export async function generatePdfFile(options: DocumentOptions, filePath: string): Promise<void> {
  const { title, content, author = 'SQL Chat' } = options;

  // Создаем PDF документ
  const pdfDoc = await PDFDocument.create();
  let page = pdfDoc.addPage([595.28, 841.89]); // A4 размер
  const { width, height } = page.getSize();

  // Загружаем шрифт
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  let yPosition = height - 50;
  const margin = 50;
  const lineHeight = 14;
  const titleHeight = 20;

  // Заголовок
  page.drawText(title, {
    x: margin,
    y: yPosition,
    size: 18,
    font: boldFont,
    color: rgb(0, 0, 0)
  });
  yPosition -= titleHeight + 20;

  // Разбиваем контент на строки
  const lines = content.split('\n');
  
  for (const line of lines) {
    if (line.trim() === '') {
      yPosition -= lineHeight / 2;
      continue;
    }

    // Проверяем, является ли строка заголовком
    if (line.startsWith('#')) {
      const level = line.match(/^#+/)?.[0].length || 1;
      const text = line.replace(/^#+\s*/, '');
      const fontSize = level === 1 ? 16 : level === 2 ? 14 : 12;
      
      page.drawText(text, {
        x: margin,
        y: yPosition,
        size: fontSize,
        font: boldFont,
        color: rgb(0, 0, 0)
      });
      yPosition -= fontSize + 5;
    } else {
      // Обычный текст
      page.drawText(line, {
        x: margin,
        y: yPosition,
        size: 12,
        font: font,
        color: rgb(0, 0, 0)
      });
      yPosition -= lineHeight;
    }

    // Проверяем, нужно ли добавить новую страницу
    if (yPosition < margin) {
      page = pdfDoc.addPage([595.28, 841.89]);
      yPosition = height - 50;
    }
  }

  // Сохраняем PDF
  const pdfBytes = await pdfDoc.save();
  fs.writeFileSync(filePath, pdfBytes);
}

// Альтернативная генерация PDF через HTML (более качественная)
export async function generatePdfFromHtml(options: DocumentOptions, filePath: string): Promise<void> {
  const { title, content } = options;

  // Создаем HTML документ
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>${title}</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
          margin: 40px;
          color: #333;
        }
        h1, h2, h3, h4 {
          color: #2c3e50;
          margin-top: 20px;
          margin-bottom: 10px;
        }
        h1 { font-size: 24px; }
        h2 { font-size: 20px; }
        h3 { font-size: 18px; }
        h4 { font-size: 16px; }
        p { margin-bottom: 10px; }
        table {
          border-collapse: collapse;
          width: 100%;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 8px;
          text-align: left;
        }
        th {
          background-color: #f2f2f2;
        }
        .emoji {
          font-size: 16px;
        }
      </style>
    </head>
    <body>
      <h1>${title}</h1>
      ${content.split('\n').map(line => {
        if (line.startsWith('#')) {
          const level = line.match(/^#+/)?.[0].length || 1;
          const text = line.replace(/^#+\s*/, '');
          return `<h${level}>${text}</h${level}>`;
        } else if (line.trim() === '') {
          return '<br>';
        } else {
          return `<p>${line}</p>`;
        }
      }).join('')}
    </body>
    </html>
  `;

  // Запускаем браузер
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  try {
    const page = await browser.newPage();
    await page.setContent(html);
    
    // Генерируем PDF
    await page.pdf({
      path: filePath,
      format: 'A4',
      margin: {
        top: '20mm',
        right: '20mm',
        bottom: '20mm',
        left: '20mm'
      },
      printBackground: true
    });
  } finally {
    await browser.close();
  }
}

// Основная функция генерации документа
export async function generateDocument(
  content: string,
  title: string,
  format: 'txt' | 'doc' | 'pdf',
  filePath: string
): Promise<void> {
  const options: DocumentOptions = {
    title,
    content,
    author: 'SQL Chat',
    subject: 'Generated Report'
  };

  switch (format) {
    case 'txt':
      await generateTxtFile(content, filePath);
      break;
    case 'doc':
      await generateDocFile(options, filePath);
      break;
    case 'pdf':
      await generatePdfFromHtml(options, filePath);
      break;
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
} 